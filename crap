#!/bin/bash
#
# ChromeOS Automated Partitioning (CRAP)
# https://github.com/chrultrabook/crap
#

set -e

fail() {
	printf "%s\n" "$*" >&2
	exit 1
}

readlink /proc/$$/exe | grep -q bash || fail "Please run with bash"
[ "$EUID" -ne 0 ] && fail "Please run as root"

get_largest_blockdev() {
	local largest size dev_name tmp_size remo
	size=0
	for blockdev in /sys/block/*; do
		dev_name="${blockdev##*/}"
		echo "$dev_name" | grep -q '^\(loop\|ram\)' && continue
		tmp_size=$(cat "$blockdev"/size)
		remo=$(cat "$blockdev"/removable)
		if [ "$tmp_size" -gt "$size" ] && [ "${remo:-0}" -eq 0 ]; then
			largest="/dev/$dev_name"
			size="$tmp_size"
		fi
	done
	echo "$largest"
}

get_largest_cros_blockdev() {
	local largest size dev_name tmp_size remo
	size=0
	for blockdev in /sys/block/*; do
		dev_name="${blockdev##*/}"
		echo "$dev_name" | grep -q '^\(loop\|ram\)' && continue
		tmp_size=$(cat "$blockdev"/size)
		remo=$(cat "$blockdev"/removable)
		if [ "$tmp_size" -gt "$size" ] && [ "${remo:-0}" -eq 0 ]; then
			case "$(fdisk -l -o name "/dev/$dev_name" 2>/dev/null)" in
				*STATE*KERN-A*ROOT-A*KERN-B*ROOT-B*)
					largest="/dev/$dev_name"
					size="$tmp_size"
					;;
			esac
		fi
	done
	echo "$largest"
}

resize_stateful_menu() {
	echo "${FUNCNAME[0]}"
}

check_1s_parts() {
	echo "${FUNCNAME[0]}"
}

fix_1s_parts() {
	echo "${FUNCNAME[0]}"
}

check_1s_parts_prompt() {
	echo "${FUNCNAME[0]}"
}

menu() {
	while true; do
		clear
		echo ""
		echo " ChromeOS Automated Partitioning (CRAP)"
		echo " https://github.com/chrultrabook/crap"
		echo "╔═════════════════════════════════════════╗"
		echo "║ Disk: $(printf "%-33.33s" "$CRAP_DISK") ║"
		echo "╠═════════════════════════════════════════╣"
		echo "║ 1) Resize stateful partition            ║"
		echo "║ 2) Reorder 1s parts                     ║"
		echo "║ Q) Quit                                 ║"
		echo "╚═════════════════════════════════════════╝"
		echo "Select an option:"
		read -re action
		case "$action" in
			1) resize_stateful_menu ;;
			2) fix_1s_parts ;;
			[qQ]) break ;;
		esac
	done
}

#CRAP_DISK="$(get_largest_cros_blockdev)"
#[ -z "$CRAP_DISK" ] && fail "No SSD found on device!"

CRAP_DISK=test.bin
[ -f "$CRAP_DISK" ] || fail "$CRAP_DISK doesn't exist or isn't a file"

check_1s_parts_prompt
menu

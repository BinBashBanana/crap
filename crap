#!/bin/bash
#
# ChromeOS Automated Partitioning (CRAP)
# https://github.com/chrultrabook/crap
#
# Thanks to the following projects/files for reference:
# https://github.com/MrChromebox/scripts
# https://chromium.googlesource.com/chromiumos/platform2/+/main/chromeos-common-script/share/chromeos-common.sh
# https://github.com/reynhout/chrx/blob/master/chrx-setup-storage
# https://gist.github.com/bendavis78/5929b46efd26232d7e9e
#

set -eE

# optional variables
[ -z "$CRAP_TESTING" ] && CRAP_TESTING=0
[ -z "$CRAP_DEBUG" ] && CRAP_DEBUG=0

# internal variables
COLOR_RESET="\033[0m"
COLOR_BLACK_B="\033[1;30m"
COLOR_RED_B="\033[1;31m"
COLOR_GREEN_B="\033[1;32m"
COLOR_YELLOW_B="\033[1;33m"
COLOR_BLUE_B="\033[1;34m"
COLOR_MAGENTA_B="\033[1;35m"
COLOR_CYAN_B="\033[1;36m"
CHAR_CHECK="\u2713"

fail() {
	printf "${COLOR_RED_B}%s\n" "$*" >&2 || :
	exit 1
}

log_debug() {
	[ "$CRAP_DEBUG" -eq 1 ] && printf "%s\n" "$*" >&2 || :
}

readlink /proc/$$/exe | grep -q bash || fail "Please run with bash"
[ "$EUID" -ne 0 ] && fail "Please run as root"
readlink /proc/$PPID/exe | grep -q crosh && fail "Please run from a VT, not from crosh. Press [ Ctrl ] [ Alt ] [ -> ] (F2) to switch to VT2."

format_bytes() {
	numfmt --to=iec-i --suffix=B "$@"
}

get_largest_blockdev() {
	local largest size dev_name tmp_size remo
	size=0
	for blockdev in /sys/block/*; do
		dev_name="${blockdev##*/}"
		echo "$dev_name" | grep -q '^\(loop\|ram\)' && continue
		tmp_size=$(cat "$blockdev"/size)
		remo=$(cat "$blockdev"/removable)
		if [ "$tmp_size" -gt "$size" ] && [ "${remo:-0}" -eq 0 ]; then
			largest="/dev/$dev_name"
			size="$tmp_size"
		fi
	done
	echo "$largest"
}

get_largest_cros_blockdev() {
	local largest size dev_name tmp_size remo
	size=0
	for blockdev in /sys/block/*; do
		dev_name="${blockdev##*/}"
		echo "$dev_name" | grep -q '^\(loop\|ram\)' && continue
		tmp_size=$(cat "$blockdev"/size)
		remo=$(cat "$blockdev"/removable)
		if [ "$tmp_size" -gt "$size" ] && [ "${remo:-0}" -eq 0 ]; then
			case "$(sfdisk -l -o name "/dev/$dev_name" 2>/dev/null)" in
				*STATE*KERN-A*ROOT-A*KERN-B*ROOT-B*)
					largest="/dev/$dev_name"
					size="$tmp_size"
					;;
			esac
		fi
	done
	echo "$largest"
}

format_part_number() {
	echo -n "$1"
	echo "$1" | grep -q '[0-9]$' && echo -n p
	echo "$2"
}

clear_screen() {
	clear
	echo ""
}

wait_on_enter() {
	echo "Press enter to return to the main menu."
	read -res
}

unmount_stateful() {
	[ "$CRAP_TESTING" -eq 1 ] && return
	grep -q "^$STATEFUL_PART" /proc/mounts || return
	echo "Unmounting stateful"
	cryptohome --action=unmount >/dev/null || :
	initctl stop ui >/dev/null || :
	initctl stop cryptohomed >/dev/null || :

	# /var and /mnt/stateful_partition will never unmount cleanly.
	# try normal umount first, then lazy if that fails.
	if grep -q "^/dev/mapper/encstateful" /proc/mounts; then
		umount -A /dev/mapper/encstateful &>/dev/null || :
		umount -Al /dev/mapper/encstateful &>/dev/null || :
	fi
	umount -A "$STATEFUL_PART" &>/dev/null || :
	umount -Al "$STATEFUL_PART"

	if grep -q "^$STATEFUL_PART" /proc/mounts; then
		return 1
	fi
	echo "Unmounted successfully"
}

refresh_stateful() {
	local stateful_start all_starts
	STATEFUL_SECTORS=$(cgpt show -i 1 -s -n -q "$CRAP_DISK")
	STATEFUL_SIZE=$((CRAP_DISK_SECTOR_SIZE * STATEFUL_SECTORS))
	STATEFUL_SIZE_HR=$(format_bytes "$STATEFUL_SIZE")
	stateful_start=$(cgpt show -i 1 -b -n -q "$CRAP_DISK")
	# important to not use -q here
	all_starts=($(cgpt show "$CRAP_DISK" | grep "^\s*[0-9]" | awk '{print $1}' | sort -n))
	for i in "${!all_starts[@]}"; do
		if [ "${all_starts[$i]}" = "$stateful_start" ]; then
			STATEFUL_NEXT_USED_SECTOR="${all_starts[$((i + 1))]}"
			break
		fi
	done
	if STATEFUL_TUNE2FS=$(tune2fs -l "$STATEFUL_PART" 2>&1); then
		STATEFUL_VALID_FS=1
		STATEFUL_BLOCK_SIZE=$(echo "$STATEFUL_TUNE2FS" | grep "Block size" | awk '{print $3}')
		STATEFUL_MIN_BLOCKS=$(resize2fs -P "$STATEFUL_PART" 2>/dev/null | grep "Estimated minimum size" | awk '{print $NF}')
		STATEFUL_FS_USAGE=$((STATEFUL_BLOCK_SIZE * STATEFUL_MIN_BLOCKS))
		STATEFUL_FS_USAGE_HR="$(format_bytes "$STATEFUL_FS_USAGE") ($(((STATEFUL_FS_USAGE / (STATEFUL_SIZE / 100))))%)"
	else
		STATEFUL_VALID_FS=0
		STATEFUL_BLOCK_SIZE=
		STATEFUL_MIN_BLOCKS=
		STATEFUL_FS_USAGE=
		STATEFUL_FS_USAGE_HR=
	fi
}

resize_stateful_menu() {
	clear_screen
	if ! unmount_stateful; then
		echo "Failed to unmount stateful."
		echo "Press enter to return to the main menu."
		read -res
		return
	fi
	refresh_stateful
	echo "Disk size: $CRAP_DISK_SIZE_HR"
	echo "Stateful size: $STATEFUL_SIZE_HR"
	[ "$STATEFUL_VALID_FS" -eq 1 ] && echo "Stateful FS usage: $STATEFUL_FS_USAGE_HR"

	# todo: get minimum and maximum possible stateful size

	refresh_stateful
	wait_on_enter
}

# try to accurately detect/mimic the problematic behavior of libparted
check_1s_parts_need_fix() {
	local part_table part_starts physical_part_table needs_move you_do_it this_num this_start this_size next_num next_start next_size
	part_table=$(cgpt show -q -n "$CRAP_DISK")
	part_starts=$(echo "$part_table" | awk '{print $1}' | sort -n)
	physical_part_table=()
	for part in $part_starts; do
		physical_part_table+=("$(echo "$part_table" | grep "^\s*${part}\s")")
	done

	needs_move=()
	you_do_it=0
	for i in "${!physical_part_table[@]}"; do
		this_num=$(echo "${physical_part_table[$i]}" | awk '{print $3}')
		if [ "$you_do_it" -eq 1 ]; then
			log_debug "[accepting defer: $this_num]"
			needs_move+=("$this_num")
			you_do_it=0
			continue
		fi
		this_start=$(echo "${physical_part_table[$i]}" | awk '{print $1}')
		this_size=$(echo "${physical_part_table[$i]}" | awk '{print $2}')
		next_num=$(echo "${physical_part_table[$((i + 1))]}" | awk '{print $3}')
		next_start=$(echo "${physical_part_table[$((i + 1))]}" | awk '{print $1}')
		next_size=$(echo "${physical_part_table[$((i + 1))]}" | awk '{print $2}')
		log_debug "me:   ${physical_part_table[$i]}"
		log_debug "next: ${physical_part_table[$((i + 1))]}"
		if [ -n "$next_num" ] && [ "$next_num" -lt "$this_num" ] && [ "$this_size" -eq 1 ] && [ "$next_start" -eq "$((this_start + 1))" ]; then
			log_debug "[problem]"
			# defer to next partition
			if [ "$next_size" -eq 1 ]; then
				log_debug "[deferring]"
				you_do_it=1
				continue
			fi
			log_debug "[not deferring: $this_num]"
			needs_move+=("$this_num")
		else
			log_debug "[no problem]"
		fi
	done
	log_debug "[needs move]: ${needs_move[@]}"

	NEEDS_1S_FIX=$(printf '%s\n' "${needs_move[@]}" | sort -n)
}

find_unallocated_sectors() {
	local allgaps
	if allgaps=$(sfdisk -F "$1" | grep "^\s*[0-9]"); then
		while read gap; do
			if [ "$(echo "$gap" | awk '{print $3}')" -ge "$2" ]; then
				echo "$gap" | awk '{print $1}'
				return
			fi
		done <<<"$allgaps"
	fi
	return 1
}

fix_1s_parts() {
	local p1s_n gapstart
	clear_screen
	check_1s_parts_need_fix
	if [ -z "$NEEDS_1S_FIX" ]; then
		echo "You do not appear to need the fix,"
		echo "but if you are having issues you can choose to force it."
		echo -e "${COLOR_CYAN_B}Would you like to force the fix? ${COLOR_YELLOW_B}(y/N)${COLOR_RESET}"
		read -re action
		case "$action" in
			[yY]) p1s_n=($(cgpt show -q -n "$CRAP_DISK" | awk '{if ($2 == 1) print $3}')) ;;
			*) return ;;
		esac
	else
		p1s_n=($NEEDS_1S_FIX)
	fi

	# 1 extra sector needed after, but not before
	gapstart=$(find_unallocated_sectors "$CRAP_DISK" "$((${#p1s_n[@]} + 1))") || :
	if [ -z "$gapstart" ]; then
		echo -e "${COLOR_RED_B}Not enough unpartitioned space on disk. Cannot continue.${COLOR_RESET}"
		wait_on_enter
		return
	fi

	log_debug "parts to move: ${p1s_n[@]}"
	log_debug "gap min: $((${#p1s_n[@]} + 1))"
	log_debug "gap start: $gapstart"

	echo "Reordering partitions..."
	for i in "${!p1s_n[@]}"; do
		log_debug cgpt add -i "${p1s_n[$i]}" -b "$((gapstart + $i))" -s 1 "$CRAP_DISK"
		cgpt add -i "${p1s_n[$i]}" -b "$((gapstart + $i))" -s 1 "$CRAP_DISK"
	done

	check_1s_parts_need_fix
	if [ -z "$NEEDS_1S_FIX" ]; then
		echo "Success."
	else
		echo -e "${COLOR_RED_B}An error occured and the partitions were not properly reordered."
		echo -e "Current partition table is shown below:${COLOR_RESET}"
		sfdisk -l "$CRAP_DISK"
	fi
	wait_on_enter
}

# todo: implement this maybe?
check_1s_parts_prompt() {
	check_1s_parts_need_fix
	[ -z "$NEEDS_1S_FIX" ] && return
	clear_screen
	echo "You need the fix"
	wait_on_enter
}

cleanup_and_exit() {
	[ "$CRAP_TESTING" -eq 1 ] && losetup -d "$CRAP_DISK"
	trap - EXIT
	exit
}

menu() {
	while true; do
		clear_screen
		echo -e " ChromeOS Automated Partitioning (CRAP)"
		echo -e " https://github.com/chrultrabook/crap"
		echo -e "╔════════════════════════════════════════════════════════════════════╗"
		echo -e "║ Disk: $(printf "%-60.60s" "$CRAP_DISK") ║"
		echo -e "║ Disk size: $(printf "%-55.55s" "$CRAP_DISK_SIZE_HR") ║"
		echo -e "║ Stateful size: $(printf "%-51.51s" "$STATEFUL_SIZE_HR") ║"
		[ "$STATEFUL_VALID_FS" -eq 1 ] && echo -e "║ Stateful FS usage: $(printf "%-47.47s" "$STATEFUL_FS_USAGE_HR") ║"
		echo -e "╠════════════════════════════════════════════════════════════════════╣"
		echo -e "║ ${COLOR_YELLOW_B}1) ${COLOR_CYAN_B}Resize stateful partition${COLOR_RESET}                                       ║"
		echo -e "║    Resize the ChromeOS user data partition to make space for an    ║"
		echo -e "║    alternate OS.                                                   ║"
		if [ -n "$NEEDS_1S_FIX" ]; then
			echo -e "║ ${COLOR_YELLOW_B}2) ${COLOR_CYAN_B}Reorder 1-sector partitions${COLOR_RESET}                                     ║"
			echo -e "║    Fix a bug that causes libparted to error and be unable to       ║"
			echo -e "║    detect existing partitions. Highly recommended before           ║"
			echo -e "║    installing linux alongside ChromeOS.                            ║"
		else
			echo -e "║ ${COLOR_BLACK_B}2) Reorder 1-sector partitions${COLOR_GREEN_B} ${CHAR_CHECK}${COLOR_RESET}                                   ║"
			echo -e "║    ${COLOR_BLACK_B}Fix a bug that causes libparted to error and be unable to${COLOR_RESET}       ║"
			echo -e "║    ${COLOR_BLACK_B}detect existing partitions. Highly recommended before${COLOR_RESET}           ║"
			echo -e "║    ${COLOR_BLACK_B}installing linux alongside ChromeOS.${COLOR_RESET}                            ║"
		fi
		echo -e "║ ${COLOR_YELLOW_B}Q) ${COLOR_CYAN_B}Quit${COLOR_RESET}                                                            ║"
		echo -e "╚════════════════════════════════════════════════════════════════════╝"
		echo -e "Select an option:"
		read -re action
		case "$action" in
			1) resize_stateful_menu ;;
			2) fix_1s_parts ;;
			[qQ]) cleanup_and_exit ;;
		esac
	done
}

if [ "$CRAP_TESTING" -eq 1 ]; then
	[ -f "$1" ] || fail "$1 doesn't exist or isn't a file"
	CRAP_DISK=$(losetup -f)
	losetup -P "$CRAP_DISK" "$1"
else
	CRAP_DISK="$(get_largest_cros_blockdev)"
	[ -z "$CRAP_DISK" ] && fail "No CrOS SSD found on device!"
fi

trap 'echo $BASH_COMMAND failed with exit code $?' ERR
trap cleanup_and_exit EXIT

CRAP_DISK_SECTOR_SIZE=$(blockdev --getss "$CRAP_DISK")
CRAP_DISK_SECTORS=$(blockdev --getsz "$CRAP_DISK")
CRAP_DISK_SIZE=$((CRAP_DISK_SECTOR_SIZE * CRAP_DISK_SECTORS))
CRAP_DISK_SIZE_HR=$(format_bytes "$CRAP_DISK_SIZE")

STATEFUL_PART=$(format_part_number "$CRAP_DISK" 1)
refresh_stateful

[ "$CRAP_TESTING" -eq 0 ] && initctl stop powerd &>/dev/null || :

#check_1s_parts_prompt
check_1s_parts_need_fix
menu
